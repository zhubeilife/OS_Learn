# jyy os 2024

## 1.操作系统概述

操作系统是一个典型的 “system”——它完成对计算机硬件系统的抽象，为应用程序提供运行的支。我们的课程从三个视角观察操作系统：
+ 从应用程序的视角看，操作系统定义了一系列的对象 (进程/线程、地址空间、文件、设备……) 和操纵它们的 API (系统调用)。
+ 从硬件的视角看，操作系统是一个拥有访问全部硬件功能的程序 (操作系统就是个 C 程序，不用怕)。
+ 从数学的视角看，一切计算机系统都是如同 “1 + 1 = 2” 一样 “well-defined” 的数学对象，这包括机器、程序，当然也包括操作系统。

课程里反复强调程序就是一个状态机，比如这里CPU的寄存器和内存就是一个状态，rv32ima_step函数根据当前的CPUState计算执行了一个指令之后的CPU状态

```c++
struct CPUState {
    // Processor internal state
    uint32_t regs[32], csrs[CSR_COUNT];

    // Memory state
    uint8_t *mem;
    uint32_t mem_offset, mem_size;
};

static inline int32_t rv32ima_step(struct CPUState *state, uint32_t elapsedUs) {
    #define CSR(x) (state->csrs[x])
    #define REG(x) (state->regs[x])
    #define MEM(x) (&state->mem[x])
```

## 2. 应用视角的操作系统

> 状态机（Finite State Machine，FSM）是一种数学模型，用于设计计算机程序和数字逻辑电路。它由有限数量的状态、状态之间的转换以及响应输入的动作组成。状态机在许多领域都有广泛的应用，比如控制系统、通信协议、图形用户界面、游戏开发等。
状态机的基本概念包括：
状态（State）：系统在某一时刻所处的状态。
转换（Transition）：从一个状态到另一个状态的改变，通常由某些事件或条件触发。
事件（Event）：引起状态转换的外部或内部输入。
动作（Action）：在状态转换过程中或在某一状态下执行的操作。

**程序是状态机**

任何程序 = minimal.S = 状态机 ： 都是被操作系统加载，设置成初始状态，然后经历（计算+syscall），最后退出

Everything (C 程序) = 状态机
状态 = 变量数值 + 栈 
初始状态 = main 的第⼀条语句 
状态迁移 = 执⾏⼀条语句中的⼀⼩步

**编译器**

编译器的输⼊
+ ⾼级语⾔ (C) 代码 = 状态机

编译器的输出
+ 汇编代码 (指令序列) = 状态机

编译器 = 状态机之间的翻译器

### Take-away Messages
Everything (高级语言代码、机器代码) 都是状态机；而编译器实现了两种状态机之间的翻译。无论何种状态机，在没有操作系统时，它们只能做纯粹的计算，甚至都不能把结果传递到程序之外——而程序与操作系统沟通的唯一桥梁是系统调用 (例如 x86-64 的 syscall 指令)。

## 3. 硬件视角的操作系统

计算机系统是严格的数学对象：没有魔法；计算机系统的一切行为都是可观测、可理解的。

+ 处理器是无情的执行指令的机器。
+ 处理器会规定好 Reset 后的行为。
+ Reset 后 Firmware 开始运行，再加载操作系统。
+ 厂商逐渐形成了达成共识的 Firmware Specification (IBM PC “兼容机”、UEFI、……)。

## 4. 数学视角的操作系统


